package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.impl.CompilerImpl;
import rs.etf.pp1.mj.runtime.*;

parser code {:
	
	
	
    Logger log = Logger.getLogger(getClass());
   
    //REDEFINE LOGGER METHODS
    //======================================================================================
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error : ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Error : parsing has to be stopped", cur_token);
    }

    public void report_error(String message, Object info)
      {
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
                  System.err.println("Error : on line " + ((Symbol)info).left);
        else System.err.println("");
      }

    //======================================================================================
:}

action code {:
	CompilerImpl impl = new CompilerImpl() ;	
:}

init with {:
  Tab.init(); 
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

//TEMINALS & NON-TERMINALS
//=====================================================================================================================

terminal PROG, LBRACE, RBRACE, SEMI_COMMA, LPAREN, RPAREN, COMMA, PRINT, RETURN, VOID, STATIC, LSQUARE, RSQUARE, READ;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal Integer NUMBER;
terminal IF, ELSE, FOR , CONTINUE, BREAK;
terminal CLASS, EXTENDS, CONST;
terminal EQ, NEQ, BGR, BGE, BLS, BLE, DOT, NEW;
terminal ADD, SUB, MUL, DIV, MOD, INC, DEC;
terminal OR, AND;
terminal String IDENT;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

non terminal Program;
non terminal ProgramName;

non terminal Type;
non terminal Value;

non terminal GlobalDeclarationList;
non terminal GlobalVarDeclarationList;
non terminal GlobalVarList;
non terminal GlobalVar;

non terminal ClassDeclaration;
non terminal ExtendedClass;

non terminal MethodListExt;
non terminal MethodList;
non terminal Method;
non terminal MethodStatic;
non terminal MethodReturnType;
non terminal MethodArgWrapper;
non terminal MethodArgList;
non terminal MethodArg;

non terminal StatementList;
non terminal Statement;
non terminal StatementSimple;
non terminal StatementComplex;

non terminal ReturnStatement;

non terminal IfStatement;
non terminal IfCondition;
non terminal Condition;
non terminal ConditionTerm;
non terminal ConditionFact;

non terminal ForStatement;
non terminal ForCondition;
non terminal ForDesignatorStatement;

non terminal DesignatorStatement;
non terminal Designator;
non terminal DesignatorRight;
non terminal ActualParameters;

non terminal ExpressionWithSign;
non terminal Expression;
non terminal TermList;
non terminal FactorList;
non terminal Factor;

non terminal AssignOp;
non terminal AddOpLeft;
non terminal AddOpRight;
non terminal MulOpLeft;
non terminal MulOpRight;
non terminal RelOp;


non terminal LocalVarWrapper;
non terminal LocalVarListExt;
non terminal LocalVarList;
non terminal LocalVar;

non terminal ConstDeclarationList;
non terminal ConstList;
non terminal ConstDecl;

precedence left ELSE;

//LANGUAGE GRAMMAR
//=====================================================================================================================

Program ::= PROG ProgramName:pName GlobalDeclarationList MethodListExt {: impl.endProgram(); :};

ProgramName ::= IDENT:stringProgramName {: impl.startProgram(stringProgramName); :};

//==============================================================================


//==============================================================================

GlobalDeclarationList ::=    GlobalDeclarationList ClassDeclaration
                            |GlobalDeclarationList ConstDeclarationList
                            |GlobalDeclarationList GlobalVarDeclarationList
                            |/*epsilon*/;
//==============================================================================

ConstDeclarationList ::= CONST Type:structType {: impl.setCurrentType(structType); :} ConstList SEMI_COMMA ;

ConstList ::=    ConstDecl COMMA ConstList
                |ConstDecl;

ConstDecl ::= IDENT:stringConstName ASSIGN Value:objectValue {: impl.defineConst(stringConstName,objectValue,stringConstNameleft); :};


Type ::= IDENT:stringTypeName {: RESULT = impl.findType(stringTypeName, stringTypeNameleft); :};

Value ::=  NUMBER:object {: RESULT = object; :}
          |CHARCONST:object {: RESULT = object; :}
          |BOOLCONST:object {: RESULT = object; :};

//==============================================================================

GlobalVarDeclarationList ::= Type:structType {: impl.setCurrentType(structType); :} GlobalVarList SEMI_COMMA ;

GlobalVarList ::=  GlobalVar COMMA GlobalVarList
                  |GlobalVar;

GlobalVar ::=  IDENT:stringVarName {: impl.defineVar(stringVarName,true,stringVarNameleft); :}
              |IDENT:stringVarName LSQUARE RSQUARE {: impl.defineArray(stringVarName, true, stringVarNameleft); :};

//==============================================================================

ClassDeclaration ::= CLASS IDENT:stringClassName {: impl.defineClass(stringClassName, stringClassNameleft); :}  ExtendedClass LBRACE LocalVarWrapper MethodListExt RBRACE {: impl.endClass(); :};

ExtendedClass ::=  EXTENDS Type
                  |/*epsilon*/;

//==============================================================================

MethodListExt ::=  LBRACE MethodList RBRACE
                  |/*epsilon*/;

MethodList ::=  MethodList Method
               |/*epsilon*/;

Method ::= MethodStatic MethodReturnType LPAREN MethodArgWrapper RPAREN LocalVarWrapper {: impl.enterMethod(); :} LBRACE StatementList RBRACE:line {: impl.endMethod(lineleft); :} ;

MethodStatic ::=  STATIC
                 |/*epsilon*/;

MethodReturnType ::=  Type:stringTypeName IDENT:stringIdName {: impl.defineMethod(stringTypeName,stringIdName,stringIdNameleft); :}
                     |VOID IDENT:stringTypeName {: impl.defineMethod(null, stringTypeName, stringTypeNameleft); :};

MethodArgWrapper ::=  MethodArgList
                     |/*epsilon*/;

MethodArgList ::=  MethodArg
                  |MethodArg COMMA MethodArgList;

MethodArg ::=  Type:structType IDENT:stringIdName {: impl.defineMethodArg(structType, stringIdName, stringIdNameleft); :}
              |Type IDENT LSQUARE RSQUARE;

//==============================================================================

LocalVarWrapper ::=  LocalVarWrapper LocalVarListExt
                    |/*epsilon*/;

LocalVarListExt ::= Type:tName {: impl.setCurrentType(tName); :} LocalVarList SEMI_COMMA ;

LocalVarList ::=  LocalVar
                 |LocalVar COMMA LocalVarList;
                 
LocalVar ::=  IDENT:vName {: impl.defineVar(vName, false, vNameleft); :}
             |IDENT:vName LSQUARE RSQUARE {: impl.defineArray(vName, false, vNameleft); :};

//==============================================================================
//STATEMENT
//==============================================================================
StatementList ::=  StatementList Statement
                  |/*epsilon*/;

Statement ::=  StatementSimple
              |StatementComplex;


StatementComplex ::=  IfStatement
                     |ForStatement
                     |LBRACE StatementList RBRACE;

ReturnStatement ::=  RETURN:l ExpressionWithSign:str  {: impl.returnMatched(str,lleft); :}
                    |RETURN:l {: impl.returnMatched(Tab.noType,lleft); :};

IfStatement ::=  IfCondition Statement ELSE {: impl.endIfPart(); :} Statement {: impl.endIf(); :}
                |IfCondition Statement {: impl.endIf(); :} ;

IfCondition ::= IF LPAREN Condition RPAREN;

Condition ::=  ConditionTerm {: impl.addConditionTerm(); :}
              |ConditionTerm OR Condition;

ConditionTerm ::=    ConditionFact
                    |ConditionFact AND ConditionTerm;

ConditionFact ::=  ExpressionWithSign:expr1 {: impl.addConditionFact(expr1,expr1left); :}
                  |ExpressionWithSign:expr1 RelOp:integerOpCode ExpressionWithSign:expr2 {: impl.addConditionFact(expr1,integerOpCode, expr2, integerOpCodeleft); :};

ForStatement ::= ForCondition Statement;

ForCondition ::= FOR LPAREN ForDesignatorStatement SEMI_COMMA Condition SEMI_COMMA ForDesignatorStatement RPAREN;

ForDesignatorStatement ::=  DesignatorStatement
                           |/*epsilon*/;


StatementSimple ::=  BREAK SEMI_COMMA
                    |CONTINUE SEMI_COMMA
                    |ReturnStatement SEMI_COMMA
                    |DesignatorStatement SEMI_COMMA
                    |READ LPAREN Designator:d RPAREN SEMI_COMMA {: impl.addRead(d, dleft); :}
                    |PRINT LPAREN ExpressionWithSign:str RPAREN SEMI_COMMA {: impl.addPrint(str, 0, strleft); :}
                    |PRINT LPAREN ExpressionWithSign:str COMMA NUMBER:len RPAREN SEMI_COMMA {: impl.addPrint(str, len, strleft); :};

//==============================================================================
//DESIGNATOR //returns Obj
//==============================================================================

DesignatorStatement ::=  Designator:obj {: impl.setInAssign(true); :} AssignOp:op  ExpressionWithSign:structExpression {: impl.addAssign(obj,op,structExpression,objleft); impl.setInAssign(false); :}
                        |Designator LPAREN ActualParameters RPAREN
                        |Designator:obj INC {: impl.addIncrement(obj,objleft); :}
                        |Designator:obj DEC {: impl.addDecrement(obj,objleft); :}; 

Designator ::=   Designator DOT DesignatorRight
                |DesignatorRight:obj {: RESULT = obj; :};

DesignatorRight ::=  IDENT:id {: impl.setDesignatorArrayExtension(id,idleft);  :} LSQUARE {: impl.designatorExtensionResolveArray(idleft); :} ExpressionWithSign:ex {: impl.checkInteger(ex,exleft); :} RSQUARE {: RESULT = impl.designatorResolveIdentificator(id,idleft); :}
                    |IDENT:id {: RESULT = impl.designatorResolveIdentificator(id,idleft); :};

ActualParameters ::= ExpressionWithSign COMMA ActualParameters
                     |
                     ExpressionWithSign;

//==============================================================================
//EXPRESSION //returns Struct
//==============================================================================

ExpressionWithSign ::=  SUB Expression:objExpression {: RESULT = ((Obj)objExpression).getType(); impl.addNegation(); impl.setFromDesignator(false); :}
                       |Expression:objExpression {: RESULT = ((Obj)objExpression).getType(); impl.setFromDesignator(false); :} ;

Expression ::=  TermList:objTermList {: RESULT =  objTermList; impl.checkArrayFactorList(objTermList); :}
               |TermList:objTermList AddOpRight:intOpCode {: impl.incrementAddOpRight(); :} Expression:objExpression {: RESULT = impl.addRight(objTermList,intOpCode, objExpression, intOpCodeleft); :}
               |TermList:objTermList MulOpRight:intOpCode {: impl.incrementMulOpRight(); :} Expression:objExpression {: RESULT = impl.mulRight(objTermList, intOpCode, objExpression, intOpCodeleft); :};

TermList ::= FactorList:objFactorList {: RESULT = objFactorList; :}
            |TermList:objTermList {: impl.loadIfArray(objTermList); :} AddOpLeft:intOpCode {: impl.incrementAddOpLeft(); :} FactorList:objFactorList {: impl.loadIfArray(objFactorList); RESULT = impl.addLeft(objTermList, intOpCode, objFactorList, intOpCodeleft); :};

FactorList ::= Factor:objFactor {: RESULT = objFactor; impl.checkArrayFactor(objFactor); :}
              |FactorList:objFactorList {: impl.loadIfArray(objFactorList); :} MulOpLeft:intOpCode {: impl.incrementMulOpLeft(); :} Factor:objFactor {:  impl.loadIfArray(objFactorList); RESULT = impl.mulLeft(objFactorList, intOpCode, objFactor, intOpCodeleft); :};

Factor ::=  Designator:obj {: RESULT = impl.loadDesignator(obj); :}
           |Designator LPAREN RPAREN {: :}
           |Designator LPAREN ExpressionWithSign RPAREN
           |NUMBER:integerConst {: RESULT = impl.loadConstInteger(integerConst); :}
           |CHARCONST:charConst {: RESULT = impl.loadConstChar(charConst); :}
           |BOOLCONST:boolConst {: RESULT = impl.loadConstBool(boolConst); :}
           |NEW Type {: :}
           |NEW Type:structType LSQUARE ExpressionWithSign:objExpr RSQUARE {: RESULT = impl.createArray(structType,objExpr,structTypeleft); :}
           |LPAREN ExpressionWithSign:structExpression RPAREN {: RESULT = impl.createExpression(structExpression); :}
           ;

//==============================================================================
//OPERATION // returns Integer
//==============================================================================

AssignOp ::=  ASSIGN {: RESULT = new Integer(0); :}  
             |AddOpRight:intOpCode {: RESULT = intOpCode;  :} 
             |MulOpRight:intOpCode {: RESULT = intOpCode;  :}
             ;

RelOp ::=    EQ {: RESULT = new Integer(Code.eq); :}
            |NEQ {: RESULT = new Integer(Code.ne); :}
            |BGE {: RESULT = new Integer(Code.ge); :}
            |BLE {: RESULT = new Integer(Code.le); :}
            |BGR {: RESULT = new Integer(Code.gt); :}
            |BLS {: RESULT = new Integer(Code.lt); :}
            ;

AddOpLeft ::=  ADD {: RESULT = new Integer(Code.add); :}
              |SUB {: RESULT = new Integer(Code.sub); :};

AddOpRight ::=  ASSIGN_ADD {: RESULT = new Integer(Code.add);  :} 
               |ASSIGN_SUB {: RESULT = new Integer(Code.sub); :} 
               ;

MulOpRight ::=  ASSIGN_MUL {: RESULT = new Integer(Code.mul); :} 
               |ASSIGN_DIV {: RESULT = new Integer(Code.div); :} 
               |ASSIGN_MOD {: RESULT = new Integer(Code.rem); :} 
               ;

MulOpLeft ::=   MUL {: RESULT = new Integer(Code.mul); :}
               |DIV {: RESULT = new Integer(Code.div); :}
               |MOD {: RESULT = new Integer(Code.rem); :}
               ;

//==============================================================================
//
//==============================================================================