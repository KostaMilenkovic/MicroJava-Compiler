package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.impl.CompilerImpl;
import rs.etf.pp1.mj.runtime.*;

// import java.io.*;


parser code {:
	
	int printCallCount = 0;
	
	Logger log = Logger.getLogger(getClass());
   
   //REDEFINE LOGGER METHODS
    //======================================================================================
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error : ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Error : parsing has to be stopped", cur_token);
    }

    public void report_error(String message, Object info)
      {
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
                  System.err.println("Error : on line " + ((Symbol)info).left);
        else System.err.println("");
      }

    //======================================================================================
:}


action code {:
	CompilerImpl impl = new CompilerImpl() ;
	
:}


init with {:
  Tab.init(); 
  
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

//TEMINALS & NON-TERMINALS
//=====================================================================================================================

terminal PROG, LBRACE, RBRACE, SEMI_COMMA, LPAREN, RPAREN, COMMA, PRINT, RETURN, VOID, STATIC, LSQUARE, RSQUARE, READ;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal Integer NUMBER;
terminal IF, ELSE, FOR , CONTINUE, BREAK;
terminal CLASS, EXTENDS, CONST;
terminal EQ, NEQ, BGR, BGE, BLS, BLE, DOT, NEW;
terminal ADD, SUB, MUL, DIV, MOD, INC, DEC;
terminal OR, AND;
terminal String IDENT;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

non terminal Program;
non terminal ProgramName;

non terminal Type;
non terminal Value;

non terminal GlobalDeclarationList;
non terminal GlobalVarDeclarationList;
non terminal GlobalVarList;
non terminal GlobalVar;


non terminal ClassDeclaration;
non terminal ExtendedClass;


non terminal MethodListExt;
non terminal MethodList;
non terminal Method;
non terminal MethodStatic;
non terminal MethodReturnType;
non terminal MethodArgWrapper;
non terminal MethodArgList;
non terminal MethodArg;

non terminal StatementList;
non terminal Statement;
non terminal StatementSimple;
non terminal StatementComplex;

non terminal ReturnStatement;

non terminal IfStatement;
non terminal IfCondition;
non terminal Condition;
non terminal ConditionTerm;
non terminal ConditionFact;

non terminal ForStatement;
non terminal ForCondition;
non terminal ForDesignatorStatement;

non terminal DesignatorStatement;
non terminal Designator;
non terminal DesignatorRightList;
non terminal DesignatorRight;

non terminal ExpressionWithSign;
non terminal Expression;

non terminal AssignOp;
non terminal AddOp;
non terminal AddOpLeft;
non terminal AddOpRight;
non terminal MulOp;
non terminal MulOpLeft;
non terminal MulOpRight;
non terminal RelOp;

non terminal ActualParameters;

non terminal Term;
non terminal ExpressionRight;
non terminal Factor;


non terminal LocalVarWrapper;
non terminal LocalVarListExt;
non terminal LocalVarList;
non terminal LocalVar;

non terminal ConstDeclarationList;

non terminal ConstList;
non terminal ConstDecl;


precedence left ELSE;

//LANGUAGE GRAMMAR
//=====================================================================================================================

Program ::= PROG ProgramName GlobalDeclarationList MethodListExt ;

ProgramName ::= IDENT;

//=================

Type ::= IDENT;

Value ::= NUMBER:value 
          |
          CHARCONST:value
          |
          BOOLCONST:value
          ;

//==============================================================================

GlobalDeclarationList ::=   GlobalDeclarationList ClassDeclaration
                            |
                            GlobalDeclarationList ConstDeclarationList
                            |
                            GlobalDeclarationList GlobalVarDeclarationList
                            |
                            /*epsilon*/
                            ;
//=====

ConstDeclarationList ::= CONST Type:tName ConstList SEMI_COMMA ;


ConstList ::=   ConstDecl COMMA ConstList
                |
                ConstDecl
                ;

ConstDecl ::= IDENT ASSIGN Value;

//=====

GlobalVarDeclarationList ::= Type GlobalVarList SEMI_COMMA ;

GlobalVarList ::= GlobalVar COMMA GlobalVarList
                  |
                  GlobalVar;

GlobalVar ::= IDENT
              |
              IDENT LSQUARE RSQUARE;



//==============================================================================

ClassDeclaration ::= CLASS Type ExtendedClass LBRACE LocalVarWrapper MethodListExt RBRACE;

ExtendedClass ::= EXTENDS Type
                  |
                  /*epsilon*/
                  ;

//==============================================================================

MethodListExt ::= LBRACE MethodList RBRACE;


MethodList ::= MethodList Method
                    |
                    /*epsilon*/
                    ;

Method ::= MethodStatic MethodReturnType LPAREN MethodArgWrapper RPAREN LocalVarWrapper LBRACE StatementList RBRACE ;

MethodStatic ::= STATIC
                 |
                 /*epsilon*/
                 ;

MethodReturnType ::= Type IDENT
                     |
                     VOID IDENT
                     ;

MethodArgWrapper ::= MethodArgList
                    |
                    /*epsilon*/
                    ;

MethodArgList ::= MethodArg
                  |
                  MethodArg COMMA MethodArgList
                  ;

MethodArg ::= Type IDENT
              |
              Type IDENT LSQUARE RSQUARE;



//=========

LocalVarWrapper ::= LocalVarWrapper LocalVarListExt
                    |
                    /*epsilon*/
                    ;

LocalVarListExt ::= Type LocalVarList SEMI_COMMA ;

LocalVarList ::= LocalVar
                 |
                 LocalVar COMMA LocalVarList;
                 

LocalVar ::= IDENT:vName
             |
             IDENT:vName LSQUARE RSQUARE;

//==============================================================================


StatementList ::= StatementList Statement
                 |
                 /*epsilon*/
                 ;

Statement ::= StatementSimple
              |
              StatementComplex;

StatementSimple ::= BREAK SEMI_COMMA
                    |
                    CONTINUE SEMI_COMMA
                    |
                    ReturnStatement SEMI_COMMA
                    |
                    DesignatorStatement SEMI_COMMA
                    |
                    READ LPAREN Designator RPAREN SEMI_COMMA
                    |
                    PRINT LPAREN ExpressionWithSign RPAREN SEMI_COMMA | PRINT LPAREN ExpressionWithSign COMMA NUMBER RPAREN SEMI_COMMA
                    ;

StatementComplex ::= IfStatement
                     |
                     ForStatement
                     |
                     LBRACE StatementList RBRACE
                     ;

ReturnStatement ::= RETURN ExpressionWithSign 
                    |
                    RETURN
                    ;

IfStatement ::= IfCondition Statement ELSE Statement 
                |
                IfCondition Statement;

IfCondition ::= IF LPAREN Condition RPAREN;

Condition ::= ConditionTerm
              |
              ConditionTerm OR Condition;

ConditionTerm ::=   ConditionFact
                    |
                    ConditionFact AND ConditionTerm;

ConditionFact ::= ExpressionWithSign
                  |
                  ExpressionWithSign RelOp ExpressionWithSign;

ForStatement ::= ForCondition Statement;

ForCondition ::= FOR LPAREN ForDesignatorStatement SEMI_COMMA Condition SEMI_COMMA ForDesignatorStatement RPAREN;

ForDesignatorStatement ::= DesignatorStatement
                           |
                           /*epsilon*/
                           ;


DesignatorStatement ::= Designator AssignOp ExpressionWithSign 
                        |
                        Designator LPAREN ActualParameters RPAREN
                        |
                        Designator INC
                        |
                        Designator DEC;

ActualParameters ::= ExpressionWithSign COMMA ActualParameters
                     |
                     ExpressionWithSign;

ExpressionWithSign ::= SUB Expression
                       |
                       Expression;

Expression ::= Term ExpressionRight
               |
               Term;

ExpressionRight ::= AddOp Term;
                    

Term ::= Factor
         |
         Factor MulOp Factor;

Factor ::= Designator
           |
           Designator LPAREN RPAREN
           |
           Designator LPAREN ExpressionWithSign RPAREN
           |
           NUMBER
           |
           CHARCONST
           |
           BOOLCONST
           |
           NEW Type
           |
           NEW Type LSQUARE ExpressionWithSign RSQUARE
           |
           LPAREN ExpressionWithSign RPAREN
           ;

Designator ::= DesignatorRightList;

DesignatorRightList ::= DesignatorRightList DOT DesignatorRight
                        |
                        DesignatorRight;

DesignatorRight ::= IDENT LSQUARE ExpressionWithSign RSQUARE
                    |
                    IDENT;

AssignOp ::= ASSIGN | AddOpRight | MulOpRight;
//
RelOp ::= EQ | NEQ | BGE | BLE | BGR | BLS;
//
AddOp ::= AddOpLeft
          |
          AddOpRight;

AddOpLeft ::= ADD
              |
              SUB;

AddOpRight ::= ASSIGN_ADD
               |
               ASSIGN_SUB;
//
MulOp ::= MulOpLeft
          |
          MulOpRight
          ;

MulOpRight ::= ASSIGN_MUL
               |
               ASSIGN_DIV
               |
               ASSIGN_MOD;

MulOpLeft ::=  MUL
               |
               DIV
               |
               MOD;



