package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.impl.CompilerImpl;
import rs.etf.pp1.mj.runtime.*;

// import java.io.*;


parser code {:
	
	
	
	Logger log = Logger.getLogger(getClass());
   
    //REDEFINE LOGGER METHODS
    //======================================================================================
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error : ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Error : parsing has to be stopped", cur_token);
    }

    public void report_error(String message, Object info)
      {
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
                  System.err.println("Error : on line " + ((Symbol)info).left);
        else System.err.println("");
      }

    //======================================================================================
:}


action code {:
	CompilerImpl impl = new CompilerImpl() ;
	
:}


init with {:
  Tab.init(); 
  
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

//TEMINALS & NON-TERMINALS
//=====================================================================================================================

terminal PROG, LBRACE, RBRACE, SEMI_COMMA, LPAREN, RPAREN, COMMA, PRINT, RETURN, VOID, STATIC, LSQUARE, RSQUARE, READ;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal Integer NUMBER;
terminal IF, ELSE, FOR , CONTINUE, BREAK;
terminal CLASS, EXTENDS, CONST;
terminal EQ, NEQ, BGR, BGE, BLS, BLE, DOT, NEW;
terminal ADD, SUB, MUL, DIV, MOD, INC, DEC;
terminal OR, AND;
terminal String IDENT;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

non terminal Program;
non terminal ProgramName;

non terminal Type;
non terminal Value;

non terminal GlobalDeclarationList;
non terminal GlobalVarDeclarationList;
non terminal GlobalVarList;
non terminal GlobalVar;


non terminal ClassDeclaration;
non terminal ExtendedClass;


non terminal MethodListExt;
non terminal MethodList;
non terminal Method;
non terminal MethodStatic;
non terminal MethodReturnType;
non terminal MethodArgWrapper;
non terminal MethodArgList;
non terminal MethodArg;

non terminal StatementList;
non terminal Statement;
non terminal StatementSimple;
non terminal StatementComplex;

non terminal ReturnStatement;

non terminal IfStatement;
non terminal IfCondition;
non terminal Condition;
non terminal ConditionTerm;
non terminal ConditionFact;

non terminal ForStatement;
non terminal ForCondition;
non terminal ForDesignatorStatement;

non terminal DesignatorStatement;
non terminal Designator;
non terminal DesignatorRightList;
non terminal DesignatorRight;

non terminal ExpressionWithSign;
non terminal Expression;


non terminal AssignOp;
non terminal AddOp;
non terminal AddOpLeft;
non terminal AddOpRight;
non terminal MulOp;
non terminal MulOpLeft;
non terminal MulOpRight;
non terminal RelOp;

non terminal ActualParameters;

non terminal Term;
non terminal FactorList;
non terminal Factor;


non terminal LocalVarWrapper;
non terminal LocalVarListExt;
non terminal LocalVarList;
non terminal LocalVar;

non terminal ConstDeclarationList;

non terminal ConstList;
non terminal ConstDecl;


precedence left ELSE;

//LANGUAGE GRAMMAR
//=====================================================================================================================

Program ::= PROG ProgramName:pName GlobalDeclarationList MethodListExt {: impl.endProgram(); :};

ProgramName ::= IDENT:stringProgramName {: impl.startProgram(stringProgramName); :};

//=================

Type ::= IDENT:stringTypeName {: RESULT = impl.findType(stringTypeName, stringTypeNameleft); :};

Value ::= NUMBER:object {: RESULT = object; :}
          |
          CHARCONST:object {: RESULT = object; :}
          |
          BOOLCONST:object {: RESULT = object; :}
          ;

//==============================================================================

GlobalDeclarationList ::=   GlobalDeclarationList ClassDeclaration
                            |
                            GlobalDeclarationList ConstDeclarationList
                            |
                            GlobalDeclarationList GlobalVarDeclarationList
                            |
                            /*epsilon*/
                            ;
//=====

ConstDeclarationList ::= CONST Type:structType {: impl.setCurrentType(structType); :} ConstList SEMI_COMMA ;


ConstList ::=   ConstDecl COMMA ConstList
                |
                ConstDecl
                ;

ConstDecl ::= IDENT:stringConstName ASSIGN Value:objectValue {: impl.defineConst(stringConstName,objectValue,stringConstNameleft); :};

//=====

GlobalVarDeclarationList ::= Type:structType {: impl.setCurrentType(structType); :} GlobalVarList SEMI_COMMA ;

GlobalVarList ::= GlobalVar COMMA GlobalVarList
                  |
                  GlobalVar;

GlobalVar ::= IDENT:stringVarName {: impl.defineVar(stringVarName,true,stringVarNameleft); :}
              |
              IDENT:stringVarName LSQUARE RSQUARE {: impl.defineArray(stringVarName, true, stringVarNameleft); :};



//==============================================================================

ClassDeclaration ::= CLASS IDENT:stringClassName {: impl.defineClass(stringClassName, stringClassNameleft); :}  ExtendedClass LBRACE LocalVarWrapper MethodListExt RBRACE {: impl.endClass(); :};

ExtendedClass ::= EXTENDS Type
                  |
                  /*epsilon*/
                  ;

//==============================================================================

MethodListExt ::= LBRACE MethodList RBRACE
                  |
                  /*epsilon*/
                  ;


MethodList ::= MethodList Method
                    |
                    /*epsilon*/
                    ;

Method ::= MethodStatic MethodReturnType LPAREN MethodArgWrapper RPAREN LocalVarWrapper {: impl.enterMethod(); :} LBRACE StatementList RBRACE:line {: impl.endMethod(lineleft); :} ;

MethodStatic ::= STATIC
                 |
                 /*epsilon*/
                 ;

MethodReturnType ::= Type:stringTypeName IDENT:stringIdName {: impl.defineMethod(stringTypeName,stringIdName,stringIdNameleft); :}
                     |
                     VOID IDENT:stringTypeName {: impl.defineMethod(null, stringTypeName, stringTypeNameleft); :}
                     ;

MethodArgWrapper ::= MethodArgList
                    |
                    /*epsilon*/
                    ;

MethodArgList ::= MethodArg
                  |
                  MethodArg COMMA MethodArgList
                  ;

MethodArg ::= Type:structType IDENT:stringIdName {: impl.defineMethodArg(structType, stringIdName, stringIdNameleft); :}
              |
              Type IDENT LSQUARE RSQUARE;



//=========

LocalVarWrapper ::= LocalVarWrapper LocalVarListExt
                    |
                    /*epsilon*/
                    ;

LocalVarListExt ::= Type:tName {: impl.setCurrentType(tName); :} LocalVarList SEMI_COMMA ;

LocalVarList ::= LocalVar
                 |
                 LocalVar COMMA LocalVarList;
                 

LocalVar ::= IDENT:vName {: impl.defineVar(vName, false, vNameleft); :}
             |
             IDENT:vName LSQUARE RSQUARE {: impl.defineArray(vName, false, vNameleft); :};

//==============================================================================


StatementList ::= StatementList Statement
                 |
                 /*epsilon*/
                 ;

Statement ::= StatementSimple
              |
              StatementComplex;

StatementSimple ::= BREAK SEMI_COMMA
                    |
                    CONTINUE SEMI_COMMA
                    |
                    ReturnStatement SEMI_COMMA
                    |
                    DesignatorStatement SEMI_COMMA
                    |
                    READ LPAREN Designator:d RPAREN SEMI_COMMA {: impl.addRead(d, dleft); :}
                    |
                    PRINT LPAREN ExpressionWithSign:str RPAREN SEMI_COMMA {: impl.addPrint(str, 0, strleft); :}
                    | 
                    PRINT LPAREN ExpressionWithSign:str COMMA NUMBER:len RPAREN SEMI_COMMA {: impl.addPrint(str, len, strleft); :}
                    ;

StatementComplex ::= IfStatement
                     |
                     ForStatement
                     |
                     LBRACE StatementList RBRACE
                     ;

ReturnStatement ::= RETURN:l ExpressionWithSign:str  {: impl.returnMatched(str,lleft); :}
                    |
                    RETURN:l {: impl.returnMatched(Tab.noType,lleft); :}
                    ;

IfStatement ::= IfCondition Statement ELSE Statement 
                |
                IfCondition Statement;

IfCondition ::= IF LPAREN Condition RPAREN;

Condition ::= ConditionTerm
              |
              ConditionTerm OR Condition;

ConditionTerm ::=   ConditionFact
                    |
                    ConditionFact AND ConditionTerm;

ConditionFact ::= ExpressionWithSign
                  |
                  ExpressionWithSign RelOp ExpressionWithSign;

ForStatement ::= ForCondition Statement;

ForCondition ::= FOR LPAREN ForDesignatorStatement SEMI_COMMA Condition SEMI_COMMA ForDesignatorStatement RPAREN;

ForDesignatorStatement ::= DesignatorStatement
                           |
                           /*epsilon*/
                           ;


DesignatorStatement ::= Designator:obj AssignOp:op ExpressionWithSign:structExprType {: impl.addAssign(obj,op,structExprType,objleft); :}
                        |
                        Designator LPAREN ActualParameters RPAREN
                        |
                        Designator:obj INC:l {: impl.addIncrement(obj,lleft); :}
                        |
                        Designator:obj DEC:l {: impl.addDecrement(obj,lleft); :}; 

ActualParameters ::= ExpressionWithSign COMMA ActualParameters
                     |
                     ExpressionWithSign;

ExpressionWithSign ::= SUB Expression:str {: RESULT = impl.checkInteger(str,strleft); impl.addNegation(); :}
                       |
                       Expression:str {: RESULT = str; :} ;

Expression ::= Term:structTerm AddOp:intOpCode Expression:structExpression {: RESULT = impl.addOperation(structTerm,intOpCode,structExpression,intOpCodeleft); :}
               |
               Term:term {: RESULT = term; :};
                  
Term ::= FactorList:obj {: RESULT = obj; :};

FactorList ::= FactorList:structFactorListType MulOp:intOpCode Factor:structFactorType {: RESULT = impl.addOperation(structFactorListType,intOpCode,structFactorType,intOpCodeleft); :}
                |
               Factor:structType {: RESULT = structType; :};

Factor ::= Designator:obj {: impl.loadVariable(obj); RESULT = ((Obj)obj).getType(); :}
           |
           Designator LPAREN RPAREN
           |
           Designator LPAREN ExpressionWithSign RPAREN
           |
           NUMBER:integerConst {: impl.loadConstInteger(integerConst); RESULT = Tab.intType; :}
           |
           CHARCONST:charConst {: impl.loadConstChar(charConst); RESULT = Tab.charType; :}
           |
           BOOLCONST:boolConst {: impl.loadConstBool(boolConst); RESULT = new Struct(Struct.Bool); :}
           |
           NEW Type
           |
           NEW Type:structType LSQUARE ExpressionWithSign:objExpr RSQUARE {: RESULT = impl.createArray(structType,objExpr,structTypeleft); :}
           |
           LPAREN ExpressionWithSign:structExpr RPAREN {: RESULT = structExpr; :}
           ;

Designator ::= DesignatorRightList:obj {: RESULT=obj; :};

DesignatorRightList ::= DesignatorRightList DOT DesignatorRight
                        |
                        DesignatorRight:id {: RESULT = impl.getObj((String)id,idleft); :};

DesignatorRight ::= IDENT:id LSQUARE ExpressionWithSign:ex RSQUARE {: RESULT = impl.getArrayElem(id,ex,idleft); :}
                    |
                    IDENT:id {: RESULT = id; :} ;

AssignOp ::= ASSIGN {: RESULT = new Integer(0); :}  
             | 
             AddOpRight:intOpCode {: RESULT = intOpCode; :} 
             |
             MulOpRight:intOpCode {: RESULT = intOpCode; :}
             ;

RelOp ::= EQ | NEQ | BGE | BLE | BGR | BLS;

AddOp ::= AddOpLeft:intOpCode {: RESULT = intOpCode; :}
          |
          AddOpRight:intOpCode {: RESULT = intOpCode; :}
          ;

AddOpLeft ::= ADD {: RESULT = new Integer(Code.add); :}
              |
              SUB {: RESULT = new Integer(Code.sub); :};

AddOpRight ::= ASSIGN_ADD {: RESULT = new Integer(Code.add); :} 
               |
               ASSIGN_SUB {: RESULT = new Integer(Code.sub); :} 
               ;

MulOp ::= MulOpLeft:intOpCode {: RESULT = intOpCode; :}
          |
          MulOpRight:intOpCode {: RESULT = intOpCode; :}
          ;

MulOpRight ::= ASSIGN_MUL {: RESULT = new Integer(Code.mul); :} 
               |
               ASSIGN_DIV {: RESULT = new Integer(Code.div); :} 
               |
               ASSIGN_MOD {: RESULT = new Integer(Code.rem); :} 
               ;

MulOpLeft ::=  MUL {: RESULT = new Integer(Code.mul); :}
               |
               DIV {: RESULT = new Integer(Code.div); :}
               |
               MOD {: RESULT = new Integer(Code.rem); :};



